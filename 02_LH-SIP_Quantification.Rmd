---
title: "02_LH-SIP_Quantification"
author: "Tristan Caro"
date: "3/23/2022"
output: html_document
---

# Clear the environment

```{r}
rm(list=ls())
```


# Setup

```{r setup, include = FALSE}

# global knitting options for code rendering
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>")

# global knitting options for automatic saving of all plots as .png and .pdf
knitr::opts_chunk$set(
  dev = c("png", "pdf"),
  dev.args = list(pdf = list(encoding = "WinAnsi", useDingbats = FALSE)),
  fig.keep = "all",
  fig.path = file.path("fig_output", paste0(gsub("\\.[Rr]md", "", knitr::current_input()), "_"))
)
```

### Load packages
Tidyverse required. Isoverse packages available at `isoverse.org`.
```{r, message=FALSE, warning=FALSE}
# Libraries
library(tidyverse)    # CRAN v1.3.1
library(forcats)      # CRAN v0.5.1 
library(isoreader)    # [::NA/NA] v1.3.0 # CRAN v1.3.0
library(isoprocessor) # [github::isoverse/isoprocessor] v0.6.7
library(isotopia)     # [github::isoverse/isotopia] v0.5.8 
library(readxl)       # CRAN v1.3.1 
library(ggsci)        # CRAN v2.9 
library(ggborderline) # [github::wurli/ggborderline] v0.1.0
library(ggrepel)      # CRAN v0.9.1 
library(latex2exp)    # CRAN v0.5.0
library(ggdist)       # CRAN v3.0.0 
library(ggsignif)     # CRAN v0.6.2
library(ggridges)     # CRAN v0.5.3
library(cowplot)      # CRAN v1.1.1
```

### Load sourced functions
These functions are found in the `libs/` directory.
```{r}
# Sourced Functions
source(file.path("libs", "visualization.R"))              # Visualization scripts
source(file.path("libs", "chromeleon.R"))                 # Chromeleon Reader
source(file.path("libs", "error_prop.R"))                 # Error Propagation
source(file.path("libs", "calculate_turnover.R"))         # Calculate turnover rate
source(file.path("libs", "turnover_to_gen.R"))            # Turnover rate to generation time
`%nin%` = Negate(`%in%`)                                  # "Not In" function
var_to_str = function(v) {return(deparse(substitute(v)))} # Convert variable name to string
```

### Read RDS from cache
Cache is located in `cache/` directory.
```{r}
LH_SIP_data <- readRDS(file = "cache/LH_SIP_data.RDS")
LH_SIP_memcorr <- readRDS(file = "cache/LH_SIP_memcorr.RDS")
```

# Calculate Turnover

```{r}
turnover <- LH_SIP_data %>% 
  # Combine 0d --> and 3d --> datasets
  # Evaluate each row individually
  ungroup() %>%
  mutate(
    # Explicitly define incubation parameters:
    f_label = F_label_mn, # actual measured F_L
    t0 = 0, # incubation start = 0
    d_t = inc_time_d - t0, # change in time
    f_start = at2H_mn_zero,
    f_start_mc = at2H_mn_zero_mc,
    # use PAME-corrected 2F value
    f_t = `2F_alk`,
    f_t_mc = `2F_alk_mc`, # memory corrected value
    # delta 2F: change in 2F enrichment over time t
    dF = case_when(
      f_t - f_start >= 0 ~ f_t - f_start,
      f_t - f_start < 0 ~ 0),
    # Calculate Turnover Rate in days from day 0 to 7 and 0 to 3
    u_d = calculate_turnover(
      a = a, # Assimilation efficiency defined in data reduction step
      FT = f_t, # 2F at time t (at%)
      F0 = f_start, # 2F at t0 (at%)
      FL = f_label, # 2F of label (at%)
      t = d_t # change in time
      ),
    
    dF_mc = case_when(
      f_t_mc - f_start >= 0 ~ f_t_mc - f_start,
      f_t_mc - f_start < 0 ~ 0),
    
    # And a memory-corrected turnover:
    u_d_mc = calculate_turnover(
      a = a, # Assimilation efficiency defined in data reduction step
      FT = f_t_mc, # 2F at time t (at%) (memory corrected)
      F0 = f_start_mc, # 2F at t0 (at%)
      FL = f_label, # 2F of label (at%)
      t = d_t # change in time
      ),
    
    
    # calculate generation time, converting negatives to zero
    gen_d = turnover_to_gen(u_d),
    
    # And a memory corrected gen time:
    gen_d_mc = turnover_to_gen(u_d_mc),
    
    # Calculate uncertainty in turnover rate
    su_d = calculate_sigma_mu(
      # Mean values:
      a = a,
      F_L = f_label,
      F_T = f_t,
      F_0 = f_start,
      t = d_t,
      # Uncertainties:
      sF_0 = F_0_at2H_se,
      sF_L = F_label_se,
      sF_T = calibrated_at2H_without_memory_se,
      sa = sa
    ),
    
    # Same for memory corrected data
    su_d_mc = calculate_sigma_mu(
      # Mean values:
      a = a,
      F_L = f_label,
      F_T = f_t_mc,
      F_0 = f_start,
      t = d_t,
      # Uncertainties:
      sF_0 = F_0_at2H_se,
      sF_L = F_label_se,
      sF_T = calibrated_at2H_with_memory_correction_se,
      sa = sa
    )
    
  )
```

# Calculate abundance-weighted turnover

## Summarize turnover by experimental replicates

```{r}
turnover_summarized <- turnover %>% 
  group_by(
    terrain, 
    inc_time_d,
    compound
  ) %>% 
  dplyr::summarize_if(
    is.numeric, 
    mean, 
    na.rm = TRUE
  )

```

## Summarize 2F by experimental replicates


```{r}

LH_SIP_data_summarized <- LH_SIP_data %>% 
  group_by(
    terrain, 
    inc_time_d, 
    compound
  ) %>% 
  # Filter out long-chain compounds
  filter(compound %nin% c("20:0", "22:0", "24:0")) %>% 
  summarize_if(
    is.numeric, 
    mean, 
    na.rm = TRUE
  )

```

## Weight values by abundance (rel_area_FID)

```{r}

weighted_time_course <- LH_SIP_data_summarized %>%
  group_by(
    terrain, 
    inc_time_d
  ) %>% 
  dplyr::summarize(
    # Weight at2H
    at2H_weighted = 
      sum(calibrated_at2H_without_memory * rel_area_FID, na.rm = TRUE) / 
      sum(rel_area_FID, na.rm = TRUE),
    # Weight `2F_alk`
    `2F_alk_weighted` = 
      sum(`2F_alk` * rel_area_FID, na.rm = TRUE) / 
      sum(rel_area_FID, na.rm = TRUE),
    
    # Do the same for memory-corrected data:
    at2H_weighted_mc = 
      sum(calibrated_at2H_with_memory_correction * rel_area_FID, na.rm = TRUE) / 
      sum(rel_area_FID, na.rm = TRUE),
    `2F_alk_mc_weighted` = 
      sum(`2F_alk_mc` * rel_area_FID, na.rm = TRUE) / 
      sum(rel_area_FID, na.rm = TRUE),
    
    # Keep these:
    f_label = mean(F_label_mn, na.rm = TRUE),
    a = 0.6,
    t0 = 0,
    d_t = inc_time_d - t0, # change in time
    f_start = mean(at2H_mn_zero, na.rm = TRUE),
    f_start_mc = mean(at2H_mn_zero_mc, na.rm = TRUE),
    f_t = `2F_alk_weighted`,
    f_t_mc = `2F_alk_mc_weighted`,
    
    # Calculate change in 2F:
    dF_weighted = case_when(
      f_t - f_start >= 0 ~ f_t - f_start,
      f_t - f_start < 0 ~ 0),
    
    # Calculate change in 2F (MC):
    dF_weighted_mc = case_when(
      f_t_mc - f_start_mc >= 0 ~ f_t_mc - f_start_mc,
      f_t_mc - f_start_mc < 0 ~ 0),
    
  ) %>%
  # Summarize:
  dplyr::summarize_if(
    is.numeric,
    mean,
    na.rm = TRUE
  ) %>%
  
  # Calculate turnover:
  mutate(
    u_d_weighted = calculate_turnover(
      a = a,
      FT = f_t,
      F0 = f_start,
      FL = f_label,
      t = d_t
    ),
    gen_d_weighted = turnover_to_gen(u_d_weighted),
    
    # Memory-corrected turnover:
    u_d_mc_weighted = calculate_turnover(
      a = a,
      FT = f_t_mc,
      F0 = f_start_mc,
      FL = f_label,
      t = d_t
    ),
    gen_d_mc_weighted = turnover_to_gen(u_d_mc_weighted),
  )
```


# Export
```{r}
turnover %>% saveRDS(file = "cache/turnover_rates.RDS")

turnover_summarized %>% saveRDS(file = "cache/turnover_summarized.RDS")

weighted_time_course %>% saveRDS(file = "cache/turnover_weighted.RDS")
```

